LFU-кеш
LFU (Least Frequently Used) кеш працює за принципом видалення найрідше використовуваних елементів, коли досягається обмеження місткості кешу. Кожен елемент має лічильник частоти доступу, який збільшується щоразу, коли до нього звертаються. Логіка роботи забезпечує збереження тих даних, які використовуються найчастіше, і звільнення місця шляхом видалення тих, які рідко потрібні.



Розглянемо механізм роботи LFU-кешу.

Коли новий елемент додається до кешу, його частота доступу встановлюється рівною 1. Якщо кеш переповнений, видаляється елемент із найменшою частотою використання. Якщо є кілька таких елементів, видаляється той, який був доданий найраніше.

При зверненні до елемента його лічильник частоти збільшується на 1, що підвищує його пріоритет у кеші. Якщо елемента немає в кеші, повертається спеціальне значення, наприклад -1, яке сигналізує про те, що дані необхідно отримати з іншого джерела, наприклад з бази даних.

Якщо кеш заповнений, обирається елемент із найменшим лічильником частоти, і він видаляється з кешу. Це дозволяє звільнити місце для нового елемента.



Як це виглядає на практиці. Уявімо, що кеш має місткість 3. Ми додаємо елементи A, B, C, кожен із частотою використання 1.



Key	Value	Frequency
1	A	1
2	C	1
3	B	1


Після кількох звернень до A і C їх частота стає більшою, ніж у B. При додаванні нового елемента D, оскільки кеш заповнений, видаляється елемент B, тому що рідко використовується.



Key	Value	Frequency
1	A	5
2	C	3
4	D	1


Приклад спрощеної реалізації LFU:

from collections import defaultdict

class LFUCache:
    def __init__(self, capacity):
        self.capacity = capacity
        self.data = {}  # ключ -> значення
        self.freq = {}  # ключ -> частота
        self.groups = defaultdict(list)  # частота -> список ключів
        self.min_freq = 0  # мінімальна частота в кеші

    def get(self, key):
        if key not in self.data:
            return -1
        # Збільшуємо частоту
        self._update_frequency(key)
        return self.data[key]

    def put(self, key, value):
        if self.capacity == 0:
            return

        if key in self.data:
            # Оновлюємо значення та збільшуємо частоту
            self.data[key] = value
            self._update_frequency(key)
        else:
            if len(self.data) >= self.capacity:
                # Видаляємо найменш часто використовуваний елемент
                self._evict_least_frequent()
            # Додаємо новий елемент
            self.data[key] = value
            self.freq[key] = 1
            self.groups[1].append(key)
            self.min_freq = 1

    def _update_frequency(self, key):
        # Поточна частота
        current_freq = self.freq[key]
        # Оновлюємо частоту
        self.freq[key] += 1
        # Видаляємо ключ зі старої групи
        self.groups[current_freq].remove(key)
        if not self.groups[current_freq]:
            del self.groups[current_freq]
            if current_freq == self.min_freq:
                self.min_freq += 1
        # Додаємо ключ у нову групу
        self.groups[self.freq[key]].append(key)

    def _evict_least_frequent(self):
        # Видаляємо елемент із мінімальною частотою
        least_frequent_keys = self.groups[self.min_freq]
        oldest_key = least_frequent_keys.pop(0)
        if not least_frequent_keys:
            del self.groups[self.min_freq]
        del self.data[oldest_key]
        del self.freq[oldest_key]



Ми використовуємо defaultdict(list) для зберігання ключів, згрупованих за частотами. Це спрощує реалізацію, але не є оптимальним з точки зору продуктивності. У великих системах можуть використовувати мін-купи або складніші структури для швидкого доступу до рідко використовуваного елемента. Також частота в нашій реалізації збільшується, як ціле число.

Реальні системи можуть використовувати вагові коефіцієнти або взагалі комбіновані метрики.



Хоча наша реалізація є спрощеною, але вона дозволяє ефективно зрозуміти основний принцип роботи LFU.

Клас LFUCache ініціалізується із заданою місткістю capacity, яка визначає максимальну кількість елементів у кеші. Основні атрибути класу:

self.data — зберігає пари ключ-значення;
self.freq — відстежує частоту використання кожного ключа;
self.groups — зберігає списки ключів, згруповані за частотою доступу;
self.min_freq — тримає мінімальну частоту серед усіх елементів у кеші.
Метод get дозволяє отримати значення за ключем. Якщо ключ є в кеші, значення повертається та частота доступу до ключа збільшується. Якщо ключа немає в кеші, повертається -1.

Метод put додає новий елемент у кеш або оновлює той, що існує. Якщо ключ уже є в кеші, оновлюється його значення та частота. Якщо кеш заповнений, видаляється елемент, що рідко використовується, а новий додається.

Внутрішній метод _update_frequency збільшує частоту використання ключа, а метод _evict_least_frequent видаляє елемент із мінімальною частотою. Він використовує атрибут min_freq для швидкого доступу до групи ключів із найменшою частотою.



Припустимо, у нас є LFU-кеш з місткістю у 3 елементи і такі ж самі елементи, що і для LRU-кешу.

if __name__ == "__main__":
    cache = LFUCache(3)
    cache.put(1, "Банан")
    cache.put(2, "Груша")
    cache.put(3, "Яблуко")
    print(cache.get(1))  
    cache.put(4, "Диня")
    print(cache.get(2))  # виведе -1 (не знайдено)

Розширюване дерево
Розширюване дерево (сплай-дерево, splay tree) — це самозбалансоване бінарне дерево пошуку, яке забезпечує амортизовану складність 
O
(
log
⁡
n
)
O(logn) для основних операцій (вставка, видалення, пошук).

Воно було розроблено в 1985 році Деніелом Слітором і Робертом Тар’яном. У більшості випадків операції мають часову складність 
O
(
log
⁡
n
)
O(logn), хоча можуть виникати й гірші випадки з часовою складністю 
O
(
n
)
O(n). Іншими словами, хоча в найгіршому випадку час виконання окремих операцій може сягати

O
(
n
)
O(n), амортизована, усереднена для серії операцій складність залишається 
O
(
log
⁡
n
)
O(logn). Це означає, що навіть при кількох невдалих запитах дерево в цілому залишається ефективним для великої кількості операцій.



Основна особливість розширюваних дерев — підняття вузлів до кореня після доступу, що робить часто запитувані вузли доступнішими. Кожного разу, коли до вузла звертаються (під час пошуку, вставки чи видалення), цей вузол стає коренем дерева завдяки операції сплай (splay). Це досягається шляхом виконання серії ротацій (обертання вузлів). Мета цієї стратегії — зробити доступ до часто використовуваних елементів швидшим.



Нижче в таблиці наведемо порівняння розширюваних дерев з іншими деревами



Характеристика	Сплай-дерево	AVL-дерево	Червоно-чорне дерево
Балансування	 Динамічне	Статичне	Статичне
Складність вставки	O(log n)	O(log n)	O(log n)
Складність пошуку	Амортизована — O(log n) 	O(log n)	O(log n)
Реалізація	Проста	Складніша	Складніша
Адаптивність	Висока	Низька	Низька


Головна мета Splay tree полягає не у строгому балансуванні дерева, а в забезпеченні швидкого доступу до елементів, які активно використовуються. Це досягається без необхідності у складних додаткових операціях для підтримки рівноваги, що є типовим для AVL або червоно-чорних дерев. Таким чином, розширюване дерево забезпечує природне балансування, яке адаптується до шаблону доступу.

Важливою особливістю є те, що після виконання ротацій зберігаються властивості бінарного дерева пошуку. Порядок елементів під час обхідного (in-order) перегляду дерева залишається незмінним, що гарантує правильність роботи алгоритмів пошуку та вставки.



Пошук елемента в розширюваному дереві



Процес пошуку в розширюваному дереві починається так само, як і у звичайному бінарному дереві пошуку — шляхом порівняння шуканого елемента зі значенням вузла. Однак щойно елемент знайдено, запускається спеціальна операція — сплаювання, яка переміщує цей вузол до кореня дерева. Ця процедура досягається завдяки серії ротацій.

Головна мета сплаювання — це не балансування дерева, як, наприклад, в AVL-дереві, а оптимізація доступу до недавно використаних елементів. Завдяки сплаюванню вузол, який тільки-но було знайдено, стає коренем, що дозволяє значно скоротити час його подальшого доступу.

Особливість такої організації полягає в тому, що при повторних пошуках одного й того самого елемента час доступу може скоротитися до $O(1)$. Це робить Splay Trees надзвичайно ефективними у сценаріях, де певні елементи запитуються набагато частіше за інші.



Сплай-операція в розширюваному дереві виконується для переміщення вузла до кореня. Цей процес базується на серії ротацій і може включати один із трьох основних типів ситуацій: Zig, Zig-Zig і Zig-Zag. Вибір конкретної ситуації залежить від положення вузла відносно його батьківського і прабатьківського вузлів.



Zig-ситуація

Zig-ситуація виникає, коли вузол є дочірнім вузлом безпосереднього кореня дерева. Це найпростіший тип ротації, який застосовується в певних умовах, коли ми намагаємось підняти елемент дерева ближче до кореня.






На картинці ми бачимо такі елементи:

p — це поточний корінь дерева, або батьківський вузол, який розташований вище в ієрархії.
x — це вузол, який ми бажаємо підняти до кореня дерева. Згідно з Zig-правилом, x є прямим дочірнім вузлом для p.
A, B, C — це піддерева. Вони представляють будь-які можливі елементи дерева, що можуть бути самі по собі піддеревами, і важливо звернути увагу на те, що їх порядок має бути збережено.


Тож Zig-ситуація виникає, коли вузол x, який ми намагаємося підняти до кореня, є дочірнім вузлом для кореневого вузла p. Іншими словами, x є лівим або правим дочірнім вузлом для p, і саме p є коренем дерева. У цьому випадку ми виконуємо просту ротацію, щоб підняти x і зробити його новим коренем дерева.

Взагалі можливі дві ситуації:

Якщо вузол є лівим дочірнім вузлом, виконується права ротація. Ця операція піднімає вузол до кореня, а початковий корінь стає його правим дочірнім вузлом.
Якщо вузол є правим дочірнім вузлом, виконується ліва ротація. У цьому випадку вузол стає коренем, а початковий корінь переміщується на позицію лівого дочірнього вузла.


На картинці представлена ротація, що піднімає x на рівень вище, а p опускає нижче. У цьому випадку ми бачимо просту праву ротацію, яка робить x новим коренем дерева, а p стає правим дочірнім вузлом для x.

Початковий стан — це ліва частина зображення. Елемент ****p є коренем дерева й має два дочірні вузли: x зліва та C справа. Вузол x у свою чергу має два дочірні піддерева: A та B.

Ціль ротації — підняти x на місце кореня дерева, зробивши його новим коренем. Опустити p, зробивши його дочірнім вузлом для x.



Ротація, або процес зміни зв'язків, відбувається в такий спосіб:

x піднімається на рівень вище і стає новим коренем дерева.
p переміщується до правого дочірнього вузла для x.
Піддерево B, яке раніше було правим дочірнім піддеревом для x, стає лівим піддеревом для p.
A залишається лівим піддеревом для x.
C залишається правим піддеревом для p.
Таким чином, ротація привела до того, що вузол x, який ми хотіли підняти, став коренем, а p опинився нижче, змінивши свій рівень.

Завдяки Zig-ситуації переміщення вузла до кореня відбувається дуже швидко — всього за одну операцію. Цей випадок особливо корисний, коли вузол, який необхідно перемістити, вже знаходиться у верхніх рівнях дерева.



Zig-Zig-ситуація

Zig-Zig-ситуація відбувається, коли вузол, який ми намагаємося підняти до кореня, розташований як дочірній елемент двох послідовних лівих або правих дочірніх зв'язків. У цьому випадку ми повинні виконати подвійну ротацію, яка називається Zig-Zig.






На картинці ми бачимо такі елементи:

g — це вузол, який на момент початку ротації є «дідусем» вузла x.
p — це батьківський вузол для x.
x — це вузол, який ми бажаємо підняти ближче до кореня.
A, B, C, D — це піддерева, що представляють усі можливі підвузли й самі можуть бути складними структурами.


Чому саме ротація називається Zig-Zig? Бо ми виконуємо дві послідовні ротації в одному напрямку для підняття вузла x. На картинці показаний приклад для лівої Zig-Zig-ротації, що виникає, коли вузол x знаходиться зліва від свого батька p, а p знаходиться зліва від свого батька g. Для подвійно правого випадку процес дзеркальний: виконуються дві ліві ротації.

Ціль полягає в тому, щоб підняти x до кореня, що дозволяє вирівняти дерево таким чином, що вузол, який ми часто запитуємо, опиняється на меншій глибині, чим зменшує час доступу до нього.



Давайте детальніше розглянемо процес цієї ротації крок за кроком.

На лівому зображенні міститься початковий стан дерева, де g є кореневим вузлом дерева і має два дочірні підвузли: p зліва і D справа. Вузол p також має два дочірні вузли: x зліва і C справа. Вузол x має два піддерева: A зліва і B справа.

Отже, мета ротації — підняти вузол x, зробивши його новим коренем, і зробити так, щоб p і g перемістилися нижче, зберігаючи їхню ієрархію та піддерева.

Перший крок ротації — це ротація між вузлами g та p. Ми виконуємо ротацію між g та p, щоб p став новим коренем. Вузол g переміщається на праве дочірнє місце для p. Піддерево C, яке було правим дочірнім для p, тепер стає лівим піддеревом для g.

Наступний крок — це ротація між p та x. Тепер ми виконуємо ротацію між p та x, щоб x став новим коренем. Вузол p переміщується на праве дочірнє місце для x. Піддерево B, яке було правим дочірнім для x, тепер стає лівим піддеревом для p.

У такий спосіб ми приходимо до кінцевого стану, де вузол x тепер є коренем (праве зображення).

Ротація Zig-Zig піднімає вузол x одразу на два рівні вгору, що значно скорочує шлях до нього при подальших запитах. Завдяки подвійній ротації ми вирівнюємо дерево в такий спосіб, що зменшуємо глибину вузла x, а отже, і середній час доступу до нього.

Отже, Zig-Zig-ротація дозволяє мінімізувати шлях до конкретного вузла шляхом його агресивного підйому вгору за допомогою послідовних ротацій, забезпечуючи більш збалансовану структуру дерева й підвищуючи ефективність запитів.



Zig-Zag-ситуація

Zig-Zag-ротація має особливий випадок, коли вузол, який ми намагаємося підняти, розташований як лівий або правий дочірній для свого батьківського вузла, який у свою чергу є дочірнім елементом у протилежному напрямку від «дідуся». Це означає, що вузол, який ми піднімаємо, і його батьківський вузол знаходяться в різних напрямках відносно своїх батьків, утворюючи зигзаг у структурі дерева.






На картинці ми бачимо такі елементи:

g — це вузол на вершині, тобто «дідусь» вузла x.
p — це батьківський вузол для x.
x — це вузол, який ми хочемо підняти вище, наблизити його до кореня дерева.
A, B, C, D — це піддерева, що можуть бути підструктурами, які зберігаються при виконанні ротації.


Сама Zig-Zag-ротація виконується у випадку, коли x і p знаходяться в різних напрямах відносно своїх батьків.

Наприклад:

p є лівим дочірнім вузлом для g.
x є правим дочірнім вузлом для p.
Або навпаки:

p є правим дочірнім вузлом для g.
x є лівим дочірнім вузлом для p.


Мета ротації — підняти вузол x вище, зробивши його новим коренем, зберегти структуру піддерев і уникнути асиметрії.

Сам процес Zig-Zag-ротації є симетричним і працює однаково для випадків «лівий-правий» або «правий-лівий». Такий підхід дозволяє зберігати властивості бінарного дерева пошуку й мінімізувати висоту дерева, що покращує доступ до вузлів у майбутніх операціях.



Спочатку виконується ротація між вузлами p та x так, щоб вузол x став новим батьківським вузлом для p. Таким чином, B стає лівим піддеревом для p, а p — лівим дочірнім для x. Далі виконується ротація між вузлами g та x, де вузол x стає новим коренем або вищим вузлом, а вузол g переміщується праворуч під x. Після цього піддерево C, яке було правим дочірнім вузлом для x, стає лівим дочірнім вузлом для g.

Так ми приходимо в кінцевий стан (праве зображення). Таким чином, Zig-Zag-ротація усуває асиметрію, спричинену зигзагом, і дозволяє зменшити глибину часто запитуваних вузлів, що значно підвищує ефективність роботи дерева в цілому.

Реалізація



Розглянемо програмну реалізацію Splay Tree.

class Node:
    def __init__(self, data, parent=None):
        self.data = data
        self.parent = parent
        self.left_node = None
        self.right_node = None

class SplayTree:
    def __init__(self):
        self.root = None

    def insert(self, data):
        """Вставка нового елемента в дерево."""
        if self.root is None:
            self.root = Node(data)
        else:
            self._insert_node(data, self.root)

    def _insert_node(self, data, current_node):
        """Рекурсивна вставка елемента в дерево."""
        if data < current_node.data:
            if current_node.left_node:
                self._insert_node(data, current_node.left_node)
            else:
                current_node.left_node = Node(data, current_node)
        else:
            if current_node.right_node:
                self._insert_node(data, current_node.right_node)
            else:
                current_node.right_node = Node(data, current_node)

    def find(self, data):
        """Пошук елемента в дереві із застосуванням сплаювання."""
        node = self.root
        while node is not None:
            if data < node.data:
                node = node.left_node
            elif data > node.data:
                node = node.right_node
            else:
                self._splay(node)
                return node.data
        return None  # Якщо елемент не знайдено.

    def _splay(self, node):
        """Реалізація сплаювання для переміщення вузла до кореня."""
        while node.parent is not None:
            if node.parent.parent is None:  # Zig-ситуація
                if node == node.parent.left_node:
                    self._rotate_right(node.parent)
                else:
                    self._rotate_left(node.parent)
            elif node == node.parent.left_node and node.parent == node.parent.parent.left_node:  # Zig-Zig
                self._rotate_right(node.parent.parent)
                self._rotate_right(node.parent)
            elif node == node.parent.right_node and node.parent == node.parent.parent.right_node:  # Zig-Zig
                self._rotate_left(node.parent.parent)
                self._rotate_left(node.parent)
            else:  # Zig-Zag
                if node == node.parent.left_node:
                    self._rotate_right(node.parent)
                    self._rotate_left(node.parent)
                else:
                    self._rotate_left(node.parent)
                    self._rotate_right(node.parent)

    def _rotate_right(self, node):
        """Права ротація вузла."""
        left_child = node.left_node
        if left_child is None:
            return

        node.left_node = left_child.right_node
        if left_child.right_node:
            left_child.right_node.parent = node

        left_child.parent = node.parent
        if node.parent is None:
            self.root = left_child
        elif node == node.parent.left_node:
            node.parent.left_node = left_child
        else:
            node.parent.right_node = left_child

        left_child.right_node = node
        node.parent = left_child

    def _rotate_left(self, node):
        """Ліва ротація вузла."""
        right_child = node.right_node
        if right_child is None:
            return

        node.right_node = right_child.left_node
        if right_child.left_node:
            right_child.left_node.parent = node

        right_child.parent = node.parent
        if node.parent is None:
            self.root = right_child
        elif node == node.parent.left_node:
            node.parent.left_node = right_child
        else:
            node.parent.right_node = right_child

        right_child.left_node = node
        node.parent = right_child

if __name__ == '__main__':
    splay_tree = SplayTree()
    splay_tree.insert(10)
    splay_tree.insert(8)
    splay_tree.insert(3)
    splay_tree.insert(7)

    print("Accessing 7:", splay_tree.find(7))
    print("Accessing 3:", splay_tree.find(3))
    print("Accessing 8:", splay_tree.find(8))
    print("Accessing 3:", splay_tree.find(3))
    print("Root after operations:", splay_tree.root.data)



Клас Node представляє вузол дерева й містить атрибути:

data — значення вузла,
parent — посилання на батьківський вузол,
left_node — посилання на лівий дочірній вузол,
right_node — посилання на правий дочірній вузол.
Основний клас SplayTree реалізує всі операції з деревом. Він містить кореневий вузол root, а також методи для вставки insert, пошуку find та обертання вузлів _rotate_right, _rotate_left. Давайте детально розглянемо кожен з них.



Метод insert виконує додавання нового елемента в дерево:

def insert(self, data):
        """Вставка нового елемента в дерево."""
        if self.root is None:
            self.root = Node(data)
        else:
            self._insert_node(data, self.root)

    def _insert_node(self, data, current_node):
        """Рекурсивна вставка елемента в дерево."""
        if data < current_node.data:
            if current_node.left_node:
                self._insert_node(data, current_node.left_node)
            else:
                current_node.left_node = Node(data, current_node)
        else:
            if current_node.right_node:
                self._insert_node(data, current_node.right_node)
            else:
                current_node.right_node = Node(data, current_node)



Якщо дерево порожнє, новий елемент стає коренем. Інакше викликається приватний метод _insert_node, який рекурсивно проходить по дереву, щоб знайти правильне місце для нового вузла. Новий вузол додається або зліва, або справа, залежно від значення даних, порівняно з поточним вузлом.



Метод find виконує пошук елемента в дереві:

    def find(self, data):
        """Пошук елемента в дереві із застосуванням сплаювання."""
        node = self.root
        while node is not None:
            if data < node.data:
                node = node.left_node
            elif data > node.data:
                node = node.right_node
            else:
                self._splay(node)
                return node.data
        return None  # Якщо елемент не знайдено.



Починається з кореня і проходить по дереву, порівнюючи значення поточного вузла з тим, що шукаємо. Якщо знайдено відповідний вузол, викликається метод _splay, який переміщує цей вузол до кореня за допомогою ротацій. Якщо елемент не знайдено, повертається None.



Метод _splay відповідає за те, щоб підняти певний вузол до кореня дерева.

def _splay(self, node):
        """Реалізація сплаювання для переміщення вузла до кореня."""
        while node.parent is not None:
            if node.parent.parent is None:  # Zig-ситуація
                if node == node.parent.left_node:
                    self._rotate_right(node.parent)
                else:
                    self._rotate_left(node.parent)
            elif node == node.parent.left_node and node.parent == node.parent.parent.left_node:  # Zig-Zig
                self._rotate_right(node.parent.parent)
                self._rotate_right(node.parent)
            elif node == node.parent.right_node and node.parent == node.parent.parent.right_node:  # Zig-Zig
                self._rotate_left(node.parent.parent)
                self._rotate_left(node.parent)
            else:  # Zig-Zag
                if node == node.parent.left_node:
                    self._rotate_right(node.parent)
                    self._rotate_left(node.parent)
                else:
                    self._rotate_left(node.parent)
                    self._rotate_right(node.parent)



Використовуються три види операцій:

Zig-ситуація, коли вузол x є дочірнім вузлом кореневого вузла. Тут використовується проста ротація _rotate_left або _rotate_right.
Zig-Zig-випадок, коли вузол і його батько обидва є лівими або правими дочірніми вузлами у відношенні до їхніх батьків. Виконується дві однакові ротації поспіль: _rotate_right двічі або _rotate_left двічі.
Zig-Zag-випадок, коли вузол і його батько розміщені у протилежних напрямках: один лівий, інший правий. Виконується спочатку одна ротація у протилежний бік: _rotate_right або _rotate_left, потім — друга в інший бік.


Функція _rotate_right виконує праву ротацію для заданого вузла:

def _rotate_right(self, node):
        """Права ротація вузла."""
        left_child = node.left_node
        if left_child is None:
            return

        node.left_node = left_child.right_node
        if left_child.right_node:
            left_child.right_node.parent = node

        left_child.parent = node.parent
        if node.parent is None:
            self.root = left_child
        elif node == node.parent.left_node:
            node.parent.left_node = left_child
        else:
            node.parent.right_node = left_child

        left_child.right_node = node
        node.parent = left_child



Змінна left_child — це лівий дочірній вузол, який ми хочемо підняти. Якщо left_child існує, ми переосмислюємо зв'язки:

Вузол node стає правим дочірнім для свого лівого дочірнього.
Вузол left_child стає новим коренем або дочірнім для батьківського вузла node.
Ми також корегуємо вказівники на батьківські та дочірні вузли, щоб забезпечити правильні зв'язки в дереві.



Аналогічно правій ротації, ліва ротація _rotate_left працює з правим дочірнім вузлом:

def _rotate_left(self, node):
        """Ліва ротація вузла."""
        right_child = node.right_node
        if right_child is None:
            return

        node.right_node = right_child.left_node
        if right_child.left_node:
            right_child.left_node.parent = node

        right_child.parent = node.parent
        if node.parent is None:
            self.root = right_child
        elif node == node.parent.left_node:
            node.parent.left_node = right_child
        else:
            node.parent.right_node = right_child

        right_child.left_node = node
        node.parent = right_child



Змінна right_child — це правий дочірній вузол, який ми хочемо підняти. Вузол node стає лівим дочірнім для свого правого дочірнього. Вузол right_child стає новим коренем або дочірнім вузлом для батьківського вузла node. Усі відповідні вказівники на дочірні вузли корегуються.



Тепер розглянемо виконання коду. Ми спочатку вставляємо кілька елементів: 10, 8, 3, 7.

splay_tree = SplayTree()
splay_tree.insert(10)
splay_tree.insert(8)
splay_tree.insert(3)
splay_tree.insert(7)

